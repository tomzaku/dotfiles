FUNCTION  spelunker#get_current_spell_setting()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker.vim:163
Called 8 times
Total time:   0.000261
 Self time:   0.000261

count  total (s)   self (s)
    8              0.000031 	redir => spell_setting_capture
    8              0.000110 		silent execute "setlocal spell?"
    8              0.000025 	redir END
                            
                            	" ex) '      spell' -> 'spell'
    8              0.000079 	return substitute(l:spell_setting_capture, '\v(\n|\s)\C', '', 'g')

FUNCTION  spelunker#get_buffer#filter_backquoted_words()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/get_buffer.vim:94
Called 8 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
                            	" for shell command
                            	" ex) `ls -la`
    8              0.000023 	if g:spelunker_disable_backquoted_checking == 0
    8              0.000023 		return a:text
                            	endif
                            
                            	" [バッククオート内の文字列削除]
                            	" substituteを2回実行する
                            	" 関数のatomは後方参照出来ないので注意
                            	" 1回目: 改行を含む`以外の文字のマッチ
                            	" 2回目: マッチした文字列の改行以外を全部消す
                            	"
                            	" [考慮点]
                            	" 1: 改行を考慮
                            	" ex) ```
                            	"         `aaa
                            	"         bbb`
                            	"     ```
                            	" 2: 末尾のバッククオートを考慮
                            	" ex) ```
                            	"         aaaa`
                            	"         bbb`ccc
                            	"     ```
                            	return substitute(a:text, '`\([^`]*[' . a:newline_character . ']*\)\+`', '\=substitute(submatch(0), "[^' . a:newline_character . ']", "", "g")', 'g')

FUNCTION  <SNR>73_get_newline_character()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/get_buffer.vim:53
Called 8 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
    8              0.000112 	return  has('win32') || has('win64') ? "\r": "\n"

FUNCTION  spelunker#matches#get_match_pattern()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/matches.vim:41
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            	" ここに来るwordはbuffer上と同じUpper case First or Lowercase
                            	" 大文字小文字無視オプションを使わない(事故るのを防止するため)
                            	" ng: xxxAttr -> [atTr]iplePoint
                            	" priorityはhlsearchと同じ0で指定して、検索時は検索が優先されるようにする
                            	"
                            	" #10 小文字で続く場合はormatという間違いでformatのように正しい単語をハイライトしてほしくない
                            	" #51 同じように、Formatとormatでハイライトしてほしくないが、先頭大文字の場合、
                            	"     FormatとOrmatはケースセンシティブでマッチしないので単語の前の否定先読みは設定しない
                            
    1              0.000007 	let l:uc_position = match(a:word, '\v[A-Z]\C', 0)
    1              0.000001 	if l:uc_position == 0
                            		let l:pattern = '\v' . a:word . '[a-z]@!\C'
    1              0.000001 	else
                            		" start with lower case #10
    1              0.000003 		let l:pattern = '\v[A-Za-z]@<!' . a:word . '[a-z]@!\C'
    1              0.000000 	endif
                            
    1              0.000001 	return l:pattern

FUNCTION  spelunker#get_buffer#displayed()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/get_buffer.vim:21
Called 8 times
Total time:   0.014795
 Self time:   0.009510

count  total (s)   self (s)
                            	" filter済みのbufferを変数で保持する
                            	" 変数と実際のバッファーは行数が一致するようにする
                            	" filter済みのbufferで処理をしながら、foldの判定を実際のbufferで判定する
    8   0.005937   0.000652 	let l:filtered_buffer = spelunker#get_buffer#all()
                            
    8              0.000038 	let l:current_line = line('w0')
    8              0.000022 	let l:end_line = line('w$')
                            
    8              0.000019 	let l:window_text_list = []
                            
  432              0.000350 	while 1
  432              0.000880 		if foldclosed(l:current_line) > 0
                            			let l:current_line = foldclosedend(l:current_line) + 1
  432              0.000244 		endif
                            
  432              0.000596 		if l:current_line > l:end_line
    8              0.000006 			break
  424              0.000226 		endif
                            
                            		" 配列なので現在行-1のindexで取得
  424              0.001328 		let l:line = get(l:filtered_buffer, l:current_line - 1, '')
  424              0.000586 		if l:line != ''
  368              0.000918 			call add(l:window_text_list, l:line)
  424              0.000252 		endif
                            
  424              0.000732 		let l:current_line = l:current_line + 1
  432              0.000361 	endwhile
                            
    8              0.000016 	return  l:window_text_list

FUNCTION  spelunker#cases#case_counter()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/cases.vim:35
Called 1365 times
Total time:   0.019198
 Self time:   0.018941

count  total (s)   self (s)
 1365              0.005564 	if a:word =~# '\v[a-z]_\C'
                            		" x_ にマッチしたらスネークケース
   16   0.000316   0.000183 		let b:snake_case_count = spelunker#cases#get_snake_case_count() + 1
 1349              0.004953 	elseif a:word =~# '\v[a-z][A-Z]\C'
                            		" xX にマッチしたらキャメルケース
   16   0.000253   0.000129 		let b:camel_case_count = spelunker#cases#get_camel_case_count() + 1
 1365              0.000662 	endif

FUNCTION  spelunker#spellbad#get_spell_bad_list()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/spellbad.vim:12
Called 8 times
Total time:   0.243886
 Self time:   0.001438

count  total (s)   self (s)
    8   0.001145   0.000217 	call spelunker#white_list#init_white_list()
                            
                            	" spellgood で対象から外れる場合もあるので、全部チェックする必要があり
                            	" NOTE: spellgood系操作でmatch_id_dictから消してあげたらチェック不要になる。
                            	"       ただし、match_id_dictをglobalにする必要あり
    8   0.201475   0.000143 	let l:word_list = s:get_word_list(a:window_text_list)
                            
    8   0.000330   0.000069 	let l:current_spell_setting = spelunker#get_current_spell_setting()
    8              0.000491 	setlocal spell
                            
    8   0.040269   0.000410 	let l:spell_bad_list = s:filter_spell_bad_list(l:word_list)
                            
    8   0.000126   0.000058 	call spelunker#reduce_spell_setting(l:current_spell_setting)
                            
    8              0.000009 	return l:spell_bad_list

FUNCTION  spelunker#get_buffer#filter_uri()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/get_buffer.vim:57
Called 8 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    8              0.000036 	if g:spelunker_disable_uri_checking == 0
    8              0.000037 		return a:text
                            	endif
                            
                            	" FYI: https://vi.stackexchange.com/questions/3990/ignore-urls-and-email-addresses-in-spell-file/24534#24534
                            	return substitute(a:text, '\w\+:\/\/[^[:space:]]\+', '', 'g')

FUNCTION  spelunker#matches#add_matches()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/matches.vim:13
Called 8 times
Total time:   0.001648
 Self time:   0.001449

count  total (s)   self (s)
    8              0.000040 	let l:current_matched_list         = keys(a:match_id_dict)
    8              0.000019 	let l:word_list_for_delete_match   = l:current_matched_list " spellbadとして今回検知されなければ削除するリスト
    8              0.000013 	let l:match_id_dict                = a:match_id_dict
                            
   72              0.000064 	for l:word in a:spell_bad_list
   64              0.000130 		if index(l:current_matched_list, l:word) == -1
                            			" 新しく見つかった場合highlightを設定する
    1              0.000002 			let l:highlight_group = g:spelunker_spell_bad_group
    1   0.000191   0.000012 			if spelunker#white_list#is_complex_or_compound_word(l:word)
                            				let l:highlight_group = g:spelunker_complex_or_compound_word_group
    1              0.000000 			endif
                            
    1   0.000027   0.000008 			let l:pattern = spelunker#matches#get_match_pattern(l:word)
                            
    1              0.000010 			let l:match_id = matchadd(l:highlight_group, l:pattern, 0)
    1              0.000003 			let l:match_id_dict[l:word] = l:match_id
   63              0.000028 		else
                            			" すでにある場合には削除予定リストから単語消す
   63              0.000143 			let l:del_index = index(l:word_list_for_delete_match, l:word)
   63              0.000128 			call remove(l:word_list_for_delete_match, l:del_index)
   64              0.000028 		endif
   72              0.000057 	endfor
                            
    8              0.000017 	return [l:word_list_for_delete_match, l:match_id_dict]

FUNCTION  spelunker#check_displayed_words()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker.vim:11
Called 8 times
Total time:   0.263149
 Self time:   0.000492

count  total (s)   self (s)
    8   0.000656   0.000128 	if s:is_runnable() == 0
                            		call s:clear_matches()
                            		return 0
    8              0.000006 	endif
                            
    8              0.000034 	if g:spelunker_check_type != g:spelunker_check_type_cursor_hold
                            		return 0
    8              0.000005 	endif
                            
    8   0.262347   0.000217 	call spelunker#words#check_display_area()
    8              0.000007 	return 1

FUNCTION  spelunker#words#check_display_area()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/words.vim:149
Called 8 times
Total time:   0.262130
 Self time:   0.001266

count  total (s)   self (s)
    8   0.000199   0.000124 	call spelunker#cases#reset_case_counter()
                            
    8   0.015476   0.000681 	let l:window_text_list = spelunker#get_buffer#displayed()
    8   0.244079   0.000193 	let l:spell_bad_list = spelunker#spellbad#get_spell_bad_list(l:window_text_list)
                            
                            	" unique
    8              0.000183 	let l:spell_bad_list = filter(copy(l:spell_bad_list), 'index(l:spell_bad_list, v:val, v:key+1)==-1')
                            
    8   0.002161   0.000054 	call spelunker#words#highlight(l:spell_bad_list)

FUNCTION  spelunker#utils#convert_control_character_to_space()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/utils.vim:48
Called 368 times
Total time:   0.002416
 Self time:   0.002416

count  total (s)   self (s)
                            	" ex) \nabcd -> \n abcd
  368              0.002129 	return substitute(a:line, '\v(\\n|\\r|\\t)\C', '  ', "g")

FUNCTION  spelunker#cases#reset_case_counter()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/cases.vim:11
Called 8 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    8              0.000045 	let b:camel_case_count = 0
    8              0.000019 	let b:snake_case_count = 0

FUNCTION  spelunker#cases#to_first_char_upper()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/cases.vim:56
Called 88 times
Total time:   0.000419
 Self time:   0.000419

count  total (s)   self (s)
   88              0.000382 	return toupper(a:lowercase_spell[0]) . tolower(a:lowercase_spell[1:-1])

FUNCTION  spelunker#words#cut_text_word_before()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/words.vim:102
Called 1365 times
Total time:   0.016869
 Self time:   0.016869

count  total (s)   self (s)
 1365              0.004284 	let l:found_pos = stridx(a:text, a:word)
                            
 1365              0.001609 	if l:found_pos < 0
                            		return a:text
 1365              0.000612 	endif
                            
 1365              0.003064 	let l:word_length = len(a:word)
 1365              0.003831 	return strpart(a:text, l:found_pos + l:word_length)

FUNCTION  spelunker#utils#filter_list_char_length()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/utils.vim:12
Called 16 times
Total time:   0.015791
 Self time:   0.015791

count  total (s)   self (s)
   16              0.000026 	let l:filtered_word_list = []
                            
 3158              0.002103 	for word in a:word_list
 3142              0.005233 		if strlen(word) < g:spelunker_target_min_char_len
  998              0.000473 			continue
 2144              0.000873 		endif
                            
 2144              0.003613 		call add(l:filtered_word_list, word)
 2160              0.001149 	endfor
                            
   16              0.000019 	return l:filtered_word_list

FUNCTION  spelunker#utils#code_to_words()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/utils.vim:26
Called 1365 times
Total time:   0.042629
 Self time:   0.042629

count  total (s)   self (s)
 1365              0.002045 	let l:split_by   = ' '
 1365              0.001804 	let l:words_list = []
                            
                            	" 単語ごとに空白で区切った後にsplitで単語だけの配列を作る
                            	" ex) spellBadWord -> spell Bad Word -> ['spell', 'Bad', 'Word']
                            	" ex) spell_bad_word -> spell bad word -> ['spell', 'bad', 'word']
                            
                            	" ABC_DEF -> ABC DEF
 1365              0.006666 	let l:code_for_split = substitute(a:line_of_code, '_', l:split_by, "g")
                            
                            	" ABCdef -> AB Cdef
                            	" abcAPI -> abc API
 1365              0.012556 	let l:code_for_split = substitute(l:code_for_split, '\v([A-Z]@<![A-Z]|[A-Z][a-z])\C', l:split_by . "\\1", "g")
                            
                            	" AA__BB -> AA  BB -> AA BB
 1365              0.008136 	let l:code_for_split = substitute(l:code_for_split, '\v\s+', l:split_by, "g")
                            
 1365              0.005018 	return split(l:code_for_split, l:split_by)

FUNCTION  spelunker#get_buffer#filter_account_name()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/get_buffer.vim:76
Called 8 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    8              0.000028 	if g:spelunker_disable_account_name_checking == 0
    8              0.000025 		return a:text
                            	endif
                            
                            	" memo: single quote ' -> ''
                            	let l:text = substitute(a:text, '\%([a-zA-Z0-9.!#$%&''*+\/=?^_`{|}~-]\+\)\@<!@[a-zA-Z0-9.!#$%&''*+\/=?^_`{|}~-]\+', '', 'g')
                            	return substitute(l:text, '[a-zA-Z0-9.!#$%&''*+\/=?^_`{|}~-]\+@\%([a-zA-Z0-9]\([a-zA-Z0-9-]\{0,61}[a-zA-Z0-9]\)\?\(\.[a-zA-Z0-9]\([a-zA-Z0-9-]\{0,61}[a-zA-Z0-9]\)\?\)*\)\@!', '', 'g')

FUNCTION  <SNR>74_get_word_list()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/spellbad.vim:31
Called 8 times
Total time:   0.201332
 Self time:   0.005201

count  total (s)   self (s)
    8              0.000021 	let l:word_list = []
                            
  376              0.000453 	for line in a:window_text_list
  368   0.199689   0.003558 		let l:word_list = spelunker#spellbad#get_word_list_in_line(line, l:word_list)
  376              0.001047 	endfor
                            
    8              0.000008 	return l:word_list

FUNCTION  spelunker#cases#get_snake_case_count()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/cases.vim:26
Called 16 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
   16              0.000052 	if !exists('b:snake_case_count')
                            		call spelunker#cases#reset_case_counter()
   16              0.000008 	endif
                            
   16              0.000019 	return b:snake_case_count

FUNCTION  spelunker#white_list#init_white_list()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/white_list.vim:11
Called 8 times
Total time:   0.000928
 Self time:   0.000928

count  total (s)   self (s)
    8              0.000044 	if !exists('g:spelunker_white_list')
                            		let l:wl = []
                            
                            		" Programming language keywords
                            		" Common
                            		let l:wl += ['elif', 'elseif', 'elsif', 'endfor', 'endforeach', 'endif', 'endswitch', 'esac']
                            		let l:wl += ['endwhile', 'endfunc', 'endfunction', 'endtry', 'xor', 'trait']
                            
                            		" JS: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Reserved_Words
                            		let l:wl += ['let', 'const', 'var', 'typeof', 'instanceof']
                            
                            		" PHP: http://php.net/manual/ja/reserved.keywords.php
                            		let l:wl += ['foreach', 'enddeclare', 'insteadof', 'isset']
                            
                            		" Go: http://golang.jp/go_spec#Keywords
                            		let l:wl += ['func', 'chan', 'fallthrough', 'iota', 'imag', 'println']
                            
                            		" Rust: https://qnighy.hatenablog.com/entry/2017/05/28/070000
                            		let l:wl += ['struct', 'impl', 'pub', 'mut', 'ref', 'fn', 'extern', 'mod', 'priv', 'proc', 'sizeof']
                            
                            		" Ruby: http://secret-garden.hatenablog.com/entry/2015/06/30/000000
                            		let l:wl += ['nil', 'def', 'undef']
                            
                            		" Elixir
                            		let l:wl += ['defp', 'defimpl', 'defmacro', 'defmacrop', 'defmodule', 'defprotocol', 'defstruct']
                            
                            		" C: https://ja.wikipedia.org/wiki/キーワード_(C言語)
                            		let l:wl += ['typedef', 'noreturn']
                            
                            		" C++: https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89_(C%2B%2B)
                            		let l:wl += ['nullptr', 'wchar', 'constexpr', 'alignof', 'decltype', 'typeid']
                            		let l:wl += ['noexcept', 'typename', 'alignas', 'asm', 'bitand', 'bitor', 'compl']
                            
                            		" C#: https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/keywords/
                            		let l:wl += ['readonly', 'sbyte', 'stackalloc', 'ascending']
                            
                            		" Python: https://www.lifewithpython.com/2013/03/python-reserved-words.html
                            		" Java: https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89_(Java)
                            
                            		" Types
                            		" Common
                            		let l:wl += ['str', 'char', 'int', 'bool', 'dict', 'enum', 'void', 'uint', 'ulong', 'ushort']
                            		" Rust: https://qnighy.hatenablog.com/entry/2017/05/28/070000
                            		let l:wl += ['isize', 'usize', 'vec']
                            		" Go: http://golang.jp/go_spec#Constants
                            		let l:wl += ['uintptr']
                            
                            		" Commands
                            		let l:wl += ['sudo', 'grep', 'awk', 'curl', 'wget', 'mkdir', 'rmdir', 'pwd']
                            		let l:wl += ['chmod', 'chown', 'rsync', 'uniq', 'git', 'svn', 'nohup']
                            
                            		" Famous OSS or products
                            		let l:wl += ['apache', 'nginx', 'github', 'wikipedia', 'linux', 'unix', 'dos']
                            		let l:wl += ['sql', 'mysql', 'postgresql', 'postgre', 'vim', 'gvim', 'emacs', 'vscode']
                            		let l:wl += ['csh', 'bash', 'zsh', 'ksh', 'iphone', 'redis', 'memcached', 'aws', 'gcp']
                            		let l:wl += ['google', 'nvim', 'neovim', 'webkit']
                            
                            		" Programming language name: https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E%E4%B8%80%E8%A6%A7
                            		let l:wl += ['php', 'kotlin', 'clojure', 'ecma', 'lisp', 'erlang', 'clang', 'golang']
                            		let l:wl += ['fortran', 'haskell', 'jsx', 'lua', 'matlab', 'scala', 'html', 'css']
                            		let l:wl += ['javascript', 'less', 'sass', 'scss', 'csharp', 'dotnet', 'perl']
                            
                            		" Setting files
                            		let l:wl += ['ini', 'toml', 'yml', 'xml', 'json']
                            
                            		" Image file type
                            		let l:wl += ['jpeg', 'jpg', 'gif', 'png', 'svg']
                            
                            		" Top level domain: https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%83%E3%83%97%E3%83%AC%E3%83%99%E3%83%AB%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3
                            		" 最近増えたものに関しては一旦保留
                            		let l:wl += ['com', 'org', 'biz', 'xxx', 'gov', 'edu', 'tel', 'arpa', 'bitnet', 'csnet']
                            
                            		" Environment
                            		let l:wl += ['env', 'dev', 'prod', 'stg', 'qa', 'rc']
                            
                            		" Acronyms and abbreviations
                            		let l:wl += ['config', 'conf', 'goto', 'eval', 'exec', 'init', 'calc', 'iter']
                            		let l:wl += ['auth', 'sync', 'del', 'bin', 'wasm', 'ttl', 'sec', 'dom', 'cmd']
                            		let l:wl += ['tls', 'ssl', 'tmp', 'etc', 'usr', 'pos', 'ptr', 'err', 'docs']
                            		let l:wl += ['lang', 'ajax', 'async', 'attr', 'elem', 'ctrl', 'alt']
                            		let l:wl += ['asc', 'desc', 'wifi', 'url', 'ascii', 'ansi', 'unicode']
                            		let l:wl += ['cnt', 'api', 'href', 'src', 'cui', 'gui', 'webhook', 'iframe']
                            		let l:wl += ['charset', 'os', 'num', 'expr', 'msg', 'std', 'ime', 'nav', 'img']
                            		let l:wl += ['util', 'utils', 'param', 'params']
                            
                            		" Comment
                            		let l:wl += ['todo', 'fixme', 'fyi']
                            
                            		" Protocols
                            		let l:wl += ['ssh', 'http', 'https', 'tcp', 'udp', 'ftp', 'ftps', 'sftp', 'imap', 'scp']
                            
                            		" print
                            		let l:wl += ['printf', 'println', 'sprint', 'sprintf', 'sprintln', 'fprint', 'fprintf', 'fprintln']
                            
                            		" timezone
                            		let l:wl += ['gmt', 'utc']
                            
                            		" text encoding
                            		let l:wl += ['utf', 'euc', 'jis']
                            
                            		" Other
                            		let l:wl += ['referer', 'localhost', 'serializer', 'mutex', 'autoload', 'varchar', 'popup', 'header']
                            		let l:wl += ['neo', 'fazzy']
                            
                            		" spelunker.vim option name
                            		let l:wl += ['backquoted']
                            
                            		" Don't you think it is terrible?
                            		let l:wl += ['don', 'doesn', 'didn', 'ain', 'isn', 'wasn', 'aren', 'weren']
                            
                            		let g:spelunker_white_list = l:wl
    8              0.000007 	endif

FUNCTION  <SNR>74_filter_spell_bad_list()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/spellbad.vim:71
Called 8 times
Total time:   0.039859
 Self time:   0.023648

count  total (s)   self (s)
    8              0.000024 	let l:spell_bad_list  = []
                            
                            	" 言語別ホワイトリストの取得
    8              0.000013 	let l:white_list_for_lang = []
    8              0.000009 	try
    8              0.000023 		let l:filetype = &filetype
    8              0.004050 		execute 'let l:white_list_for_lang = spelunker#utils#filter_list_char_length(spelunker#white_list#white_list_' . l:filetype . '#get_white_list())'
    8              0.000105 	catch
                            		" 読み捨て
    8              0.000016 	endtry
                            
    8              0.000017 	let l:white_list_for_user = []
    8              0.000006 	try
    8              0.000058 		execute 'let l:white_list_for_user = g:spelunker_white_list_for_user'
    8              0.000069 	catch
                            		" 読み捨て
    8              0.000009 	endtry
                            
    8   0.011132   0.000101 	let l:spelunker_white_list = spelunker#utils#filter_list_char_length(g:spelunker_white_list)
                            
  648   0.005362   0.000602 	for orig_word in spelunker#utils#filter_list_char_length(a:word_list)
  640              0.001238 		let l:lowercase_word = tolower(orig_word)
                            
  640              0.004828 		if index(l:spelunker_white_list, l:lowercase_word) >= 0 || index(l:white_list_for_lang, l:lowercase_word) >= 0 || index(l:white_list_for_user, l:lowercase_word) >= 0
   32              0.000019 			continue
  608              0.000238 		endif
                            
  608              0.002547 		let [l:spell_bad_word, l:spell_bad_type] = spellbadword(l:lowercase_word)
                            
  608              0.000691 		if l:spell_bad_word != ''
                            			" Wednesdayなど、先頭大文字しかない単語があるためもう一回チェック
   88   0.001287   0.000868 			let [l:spell_bad_word, l:spell_bad_type] = spellbadword(spelunker#cases#to_first_char_upper(l:lowercase_word))
  608              0.000240 		endif
                            
  608              0.001091 		if g:spelunker_highlight_type == g:spelunker_highlight_spell_bad && l:spell_bad_type != 'bad'
                            			continue
  608              0.000233 		endif
                            
                            		" 登録は元のケースで行う。辞書登録とそのチェックにかけるときのみlowerケースになる。
                            		" 元々ここでlowercaseだけ管理し、lower,UPPER,UpperCamelCaseをmatchadd()していたが、
                            		" 最少のマッチだけを登録させる為、ここで実際に引っかかるものを登録させ、
                            		" これらをmatchaddさせる。
  608              0.001250 		if l:spell_bad_word != '' && index(l:spell_bad_list, orig_word) == -1
   64              0.000129 			call add(l:spell_bad_list, orig_word)
  608              0.000230 		endif
  616              0.000453 	endfor
                            
    8              0.000010 	return l:spell_bad_list

FUNCTION  spelunker#spellbad#get_word_list_in_line()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/spellbad.vim:41
Called 368 times
Total time:   0.196131
 Self time:   0.102111

count  total (s)   self (s)
  368              0.000589 	let l:word_list = a:word_list
  368   0.006697   0.004281 	let l:line = spelunker#utils#convert_control_character_to_space(a:line)
                            
 1733              0.001463 	while 1
                            		" 関数名、変数名ごとに抜き出し(1関数名、変数名ごとに処理)
 1733   0.028543   0.015635 		let l:match_target_word = spelunker#cases#get_first_word_in_line(l:line)
 1733              0.002937 		if l:match_target_word == ""
  368              0.000261 			break
 1365              0.000780 		endif
                            
 1365   0.031303   0.012105 		call spelunker#cases#case_counter(l:match_target_word)
                            
                            		" 次のループのための処理
 1365   0.031156   0.014287 		let l:line = spelunker#words#cut_text_word_before(l:line, l:match_target_word)
                            
                            		" 単語の抜き出し
 1365   0.056163   0.013534 		let l:find_word_list = spelunker#utils#code_to_words(l:match_target_word)
                            
 2770              0.003637 		for word in l:find_word_list
 1405              0.004746 			if index(l:word_list, word) == -1
  894              0.002208 				call add(l:word_list, word)
 1405              0.000762 			endif
 2770              0.005673 		endfor
 1733              0.001651 	endwhile
                            
  368              0.000383 	return l:word_list

FUNCTION  <SNR>48_Remove_Matches()
    Defined: ~/Projects/nvim-macos/share/nvim/runtime/plugin/matchparen.vim:198
Called 41 times
Total time:   0.000684
 Self time:   0.000684

count  total (s)   self (s)
   41              0.000341   if exists('w:paren_hl_on') && w:paren_hl_on
    2              0.000016     silent! call matchdelete(3)
    2              0.000009     let w:paren_hl_on = 0
   41              0.000046   endif

FUNCTION  nvim_treesitter#indent()
    Defined: ~/.local/share/nvim/lazy/nvim-treesitter/autoload/nvim_treesitter.vim:25
Called 1 time
Total time:   0.397619
 Self time:   0.397619

count  total (s)   self (s)
    1              0.397618 	return luaeval(printf('require"nvim-treesitter.indent".get_indent(%d)', v:lnum))

FUNCTION  <SNR>48_Highlight_Matching_Pair()
    Defined: ~/Projects/nvim-macos/share/nvim/runtime/plugin/matchparen.vim:40
Called 41 times
Total time:   0.005450
 Self time:   0.004765

count  total (s)   self (s)
                              " Remove any previous match.
   41   0.001009   0.000325   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   41              0.000236   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   41              0.000023   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   41              0.000153   let c_lnum = line('.')
   41              0.000103   let c_col = col('.')
   41              0.000051   let before = 0
                            
   41              0.000119   let text = getline(c_lnum)
   41              0.000683   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   41              0.000103   if empty(matches)
                                let [c_before, c] = ['', '']
   41              0.000032   else
   41              0.000195     let [c_before, c] = matches[1:2]
   41              0.000026   endif
   41              0.000584   let plist = split(&matchpairs, '.\zs[:,]')
   41              0.000132   let i = index(plist, c)
   41              0.000054   if i < 0
                                " not found, in Insert mode try character before the cursor
   39              0.000163     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   14              0.000027       let before = strlen(c_before)
   14              0.000013       let c = c_before
   14              0.000022       let i = index(plist, c)
   39              0.000026     endif
   39              0.000038     if i < 0
                                  " not found, nothing to do
   39              0.000045       return
                                endif
    2              0.000002   endif
                            
                              " Figure out the arguments for searchpairpos().
    2              0.000003   if i % 2 == 0
    1              0.000002     let s_flags = 'nW'
    1              0.000003     let c2 = plist[i + 1]
    1              0.000001   else
    1              0.000001     let s_flags = 'nbW'
    1              0.000002     let c2 = c
    1              0.000002     let c = plist[i - 1]
    2              0.000001   endif
    2              0.000003   if c == '['
                                let c = '\['
                                let c2 = '\]'
    2              0.000001   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    2              0.000003   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    2              0.000001   endif
                            
    2              0.000015   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    2              0.000001   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
    2              0.000011     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    2              0.000003     try
    2              0.000069       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    2              0.000002     endtry
    2              0.000001   endif
                            
                              " Limit the search to lines visible in the window.
    2              0.000007   let stoplinebottom = line('w$')
    2              0.000005   let stoplinetop = line('w0')
    2              0.000003   if i % 2 == 0
    1              0.000003     let stopline = stoplinebottom
    1              0.000001   else
    1              0.000002     let stopline = stoplinetop
    2              0.000001   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    2              0.000008   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    2              0.000001   else
    2              0.000011     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000001   endif
    2              0.000002   try
    2              0.000536     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    2              0.000002   endtry
                            
    2              0.000003   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    2              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    2              0.000008   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    2              0.000006     if exists('*matchaddpos')
    2              0.000021       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    2              0.000001     endif
    2              0.000004     let w:paren_hl_on = 1
    2              0.000001   endif

FUNCTION  spelunker#toggle#is_enabled()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/toggle.vim:65
Called 8 times
Total time:   0.000300
 Self time:   0.000225

count  total (s)   self (s)
    8              0.000094 	if !exists('b:enable_spelunker_vim')
    8   0.000181   0.000106 		if spelunker#toggle#is_enabled_global() == 1
    8              0.000011 			return 1
                            		endif
                            
                            		return 0
                            	else
                            		" b:enable_spelunker_vimがあればbuffer優先
                            		if spelunker#toggle#is_enabled_buffer() == 1
                            			return 1
                            		else
                            			return 0
                            		endif
                            
                            		if spelunker#toggle#is_enabled_global() == 0
                            			return 0
                            		endif
                            
                            		return 1
                            	endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: ~/Projects/nvim-macos/share/nvim/runtime/ftplugin.vim:15
Called 1 time
Total time:   0.002686
 Self time:   0.002686

count  total (s)   self (s)
    1              0.000007     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000001     endif
                            
    1              0.000004     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000008       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000007       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    1              0.002643         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
    2              0.000002       endfor
    1              0.000001     endif

FUNCTION  spelunker#white_list#is_complex_or_compound_word()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/white_list.vim:139
Called 1 time
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
    1              0.000003 	let l:wrong_word = tolower(a:wrong_word)
    1              0.000003 	let l:common_word_prefix  = ['re', 'dis', 'pre', 'co', 'un', 'no']
                            
                            	" function prefix
    1              0.000006 	let l:common_word_prefix += ['str', 'fprint', 'sprint', 'print', 'get', 'set', 'calc', 'sub']
    1              0.000003 	let l:common_word_prefix += ['match', 'byte', 'is', 'has', 'to']
                            
   20              0.000015 	for l:prefix in l:common_word_prefix
   19              0.000033 		if stridx(l:wrong_word, l:prefix) == 0
                            			return 1
   19              0.000007 		endif
   20              0.000008 	endfor
                            
    1              0.000004 	let l:common_word_suffix = ['able', 'ly', 'ness', 'pos', 'list', 'map', 'cmd', 'bg', 'fg', 'id', 'log', 'num']
                            
   13              0.000010 	for l:suffix in l:common_word_suffix
   12              0.000041 		if stridx(l:wrong_word, l:suffix) + strlen(l:suffix) == strlen(l:wrong_word)
                            			return 1
   12              0.000004 		endif
   13              0.000005 	endfor
                            
    1              0.000001 	return 0

FUNCTION  spelunker#toggle#is_enabled_global()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/toggle.vim:88
Called 8 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    8              0.000038 	if g:enable_spelunker_vim == 1
    8              0.000021 		return 1
                            	endif
                            
                            	return 0

FUNCTION  <SNR>65_SynSet()
    Defined: ~/Projects/nvim-macos/share/nvim/runtime/syntax/synload.vim:27
Called 1 time
Total time:   0.001694
 Self time:   0.001694

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000002   syn clear
    1              0.000002   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000000   endif
                            
    1              0.000003   0verbose let s = expand("<amatch>")
    1              0.000001   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000005     for name in split(s, '\.')
    1              0.000001       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    1              0.001662         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
    1              0.000001       endif
    2              0.000001     endfor
    1              0.000000   endif

FUNCTION  spelunker#get_buffer#filter_acronym()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/get_buffer.vim:86
Called 8 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    8              0.000019 	if g:spelunker_disable_acronym_checking == 0
    8              0.000024 		return a:text
                            	endif
                            
                            	return substitute(a:text, '\v[A-Z]+[a-z]@!\C', '', 'g')

FUNCTION  <SNR>66_is_runnable()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker.vim:214
Called 8 times
Total time:   0.000528
 Self time:   0.000228

count  total (s)   self (s)
    8   0.000392   0.000092 	if spelunker#toggle#is_enabled() == 0
                            		return 0
    8              0.000014 	endif
                            
    8              0.000049 	if g:enable_spelunker_vim_on_readonly == 0 && &readonly
                            		return 0
    8              0.000007 	endif
                            
    8              0.000010 	return 1

FUNCTION  spelunker#matches#delete_matches()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/matches.vim:62
Called 1 time
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000002 	let l:match_id_dict = a:match_id_dict
                            
    2              0.000003 	for l:word in a:word_list_for_delete
    1              0.000003 		let l:delete_match_id = get(l:match_id_dict, l:word, 0)
    1              0.000001 		if l:delete_match_id > 0
    1              0.000001 			let l:is_ok = 1
    1              0.000001 			try
                            				" recommend version is => 8.1.1739
                            				" https://github.com/vim/vim/issues/4720
    1              0.000005 				let l:is_ok = matchdelete(l:delete_match_id, a:window_id)
                            
    1              0.000002 				if l:is_ok == -1 && a:window_id == win_getid()
                            					" Issue #21
                            					" ZT/Ztコマンドで利用
                            					" vimでmatchdelete()の第2引数指定でうまく消せないのでこちらでも削除
                            					" TODO: ZT/ztコマンドの場合のみ全てのbufferに対して実行されるようにしたい
                            					let l:is_ok = matchdelete(l:delete_match_id)
    1              0.000000 				endif
                            			catch
                            				" Issue: #35, #40
                            				" nvimでmatchdelete()の第2引数がある場合にエラーになる(v0.4.3)
                            				" FYI: https://github.com/neovim/neovim/issues/12110
                            				if spelunker#matches#is_exist_match_id(l:delete_match_id) && a:window_id == win_getid()
                            					let l:is_ok = matchdelete(l:delete_match_id)
                            				endif
    1              0.000001 			finally
    1              0.000001 				if l:is_ok == 0
    1              0.000005 					let l:del_index = index(values(l:match_id_dict), l:delete_match_id)
    1              0.000001 					if l:del_index != -1
    1              0.000006 						call remove(l:match_id_dict, keys(l:match_id_dict)[l:del_index])
    1              0.000000 					endif
    1              0.000000 				endif
    1              0.000001 			endtry
    1              0.000000 		endif
    2              0.000003 	endfor
                            
    1              0.000001 	return l:match_id_dict

FUNCTION  spelunker#cases#get_camel_case_count()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/cases.vim:17
Called 16 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   16              0.000047 	if !exists('b:camel_case_count')
                            		call spelunker#cases#reset_case_counter()
   16              0.000008 	endif
                            
   16              0.000019 	return b:camel_case_count

FUNCTION  spelunker#get_buffer#all()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/get_buffer.vim:6
Called 8 times
Total time:   0.005285
 Self time:   0.004817

count  total (s)   self (s)
    8              0.001067 	let l:window_text_list = getline(1, '$')
                            
    8   0.000242   0.000121 	let l:newline_character = s:get_newline_character()
    8              0.001654 	let l:window_text = join(l:window_text_list, l:newline_character)
                            
    8   0.000265   0.000177 	let l:window_text = spelunker#get_buffer#filter_uri(l:window_text)
    8   0.000244   0.000162 	let l:window_text = spelunker#get_buffer#filter_email(l:window_text)
    8   0.000259   0.000197 	let l:window_text = spelunker#get_buffer#filter_account_name(l:window_text)
    8   0.000162   0.000112 	let l:window_text = spelunker#get_buffer#filter_acronym(l:window_text)
    8   0.000208   0.000143 	let l:window_text = spelunker#get_buffer#filter_backquoted_words(l:window_text, l:newline_character)
                            
    8              0.001135 	return split(l:window_text, l:newline_character)

FUNCTION  spelunker#reduce_spell_setting()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker.vim:156
Called 8 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    8              0.000014 	if a:spell_setting != "spell"
    8              0.000043 		setlocal nospell
    8              0.000005 	endif

FUNCTION  <SNR>2_LoadIndent()
    Defined: ~/Projects/nvim-macos/share/nvim/runtime/indent.vim:14
Called 1 time
Total time:   0.000635
 Self time:   0.000635

count  total (s)   self (s)
    1              0.000003     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    1              0.000000     endif
    1              0.000002     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000001       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000005       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    1              0.000613         exe $'runtime! indent/{name}[.]{{vim,lua}}'
    2              0.000002       endfor
    1              0.000000     endif

FUNCTION  spelunker#get_buffer#filter_email()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/get_buffer.vim:66
Called 8 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    8              0.000026 	if g:spelunker_disable_email_checking == 0
    8              0.000048 		return a:text
                            	endif
                            
                            	" FYI: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address
                            	" memo: single quote ' -> ''
                            	return substitute(a:text, '[a-zA-Z0-9.!#$%&''*+\/=?^_`{|}~-]\+@[a-zA-Z0-9]\([a-zA-Z0-9-]\{0,61}[a-zA-Z0-9]\)\?\(\.[a-zA-Z0-9]\([a-zA-Z0-9-]\{0,61}[a-zA-Z0-9]\)\?\)*', '', 'g')

FUNCTION  spelunker#words#highlight()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/words.vim:161
Called 8 times
Total time:   0.002107
 Self time:   0.000381

count  total (s)   self (s)
    8              0.000014 	let l:spell_bad_list = a:spell_bad_list
                            
                            	" matchadd()の対象が多すぎるとスクロール時に毎回処理が走るっぽく、重くなるため
    8              0.000022 	if len(l:spell_bad_list) > g:spelunker_max_hi_words_each_buf
                            		if !exists('b:is_too_much_words_notified')
                            			echon 'Too many spell bad words. (' . len(l:spell_bad_list) . ' words found.)'
                            		endif
                            
                            		let l:spell_bad_list = l:spell_bad_list[0:g:spelunker_max_hi_words_each_buf]
                            
                            		" 2回目は通知しない
                            		let b:is_too_much_words_notified = 1
    8              0.000004 	endif
                            
    8              0.000021 	if !exists('b:match_id_dict')
                            		let b:match_id_dict = {}
    8              0.000003 	endif
                            
                            	" 同じbufferながら、ウインドウを2つ開いたときに両方正しくhighlightされるように
    8              0.000019 	let l:window_id = win_getid()
    8              0.000024 	if !has_key(b:match_id_dict, l:window_id)
                            		let b:match_id_dict[l:window_id] = {}
    8              0.000003 	endif
                            
    8   0.001752   0.000105 	let [l:word_list_for_delete_match, b:match_id_dict[l:window_id]] = spelunker#matches#add_matches(l:spell_bad_list, b:match_id_dict[l:window_id])
                            
    8              0.000017 	if len(l:word_list_for_delete_match) == 0
    7              0.000006 		return
    1              0.000000 	endif
                            
    1   0.000091   0.000012 	let b:match_id_dict[l:window_id] = spelunker#matches#delete_matches(l:word_list_for_delete_match, b:match_id_dict[l:window_id], l:window_id)

FUNCTION  spelunker#cases#get_first_word_in_line()
    Defined: ~/.local/share/nvim/lazy/spelunker.vim/autoload/spelunker/cases.vim:51
Called 1733 times
Total time:   0.012908
 Self time:   0.012908

count  total (s)   self (s)
                            	" 1文字は対象としない
 1733              0.011527 	return matchstr(a:line, '\v([A-Za-z_]{2,})\C')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   0.397619             nvim_treesitter#indent()
    8   0.263149   0.000492  spelunker#check_displayed_words()
    8   0.262130   0.001266  spelunker#words#check_display_area()
    8   0.243886   0.001438  spelunker#spellbad#get_spell_bad_list()
    8   0.201332   0.005201  <SNR>74_get_word_list()
  368   0.196131   0.102111  spelunker#spellbad#get_word_list_in_line()
 1365   0.042629             spelunker#utils#code_to_words()
    8   0.039859   0.023648  <SNR>74_filter_spell_bad_list()
 1365   0.019198   0.018941  spelunker#cases#case_counter()
 1365   0.016869             spelunker#words#cut_text_word_before()
   16   0.015791             spelunker#utils#filter_list_char_length()
    8   0.014795   0.009510  spelunker#get_buffer#displayed()
 1733   0.012908             spelunker#cases#get_first_word_in_line()
   41   0.005450   0.004765  <SNR>48_Highlight_Matching_Pair()
    8   0.005285   0.004817  spelunker#get_buffer#all()
    1   0.002686             <SNR>1_LoadFTPlugin()
  368   0.002416             spelunker#utils#convert_control_character_to_space()
    8   0.002107   0.000381  spelunker#words#highlight()
    1   0.001694             <SNR>65_SynSet()
    8   0.001648   0.001449  spelunker#matches#add_matches()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1              0.397619  nvim_treesitter#indent()
  368   0.196131   0.102111  spelunker#spellbad#get_word_list_in_line()
 1365              0.042629  spelunker#utils#code_to_words()
    8   0.039859   0.023648  <SNR>74_filter_spell_bad_list()
 1365   0.019198   0.018941  spelunker#cases#case_counter()
 1365              0.016869  spelunker#words#cut_text_word_before()
   16              0.015791  spelunker#utils#filter_list_char_length()
 1733              0.012908  spelunker#cases#get_first_word_in_line()
    8   0.014795   0.009510  spelunker#get_buffer#displayed()
    8   0.201332   0.005201  <SNR>74_get_word_list()
    8   0.005285   0.004817  spelunker#get_buffer#all()
   41   0.005450   0.004765  <SNR>48_Highlight_Matching_Pair()
    1              0.002686  <SNR>1_LoadFTPlugin()
  368              0.002416  spelunker#utils#convert_control_character_to_space()
    1              0.001694  <SNR>65_SynSet()
    8   0.001648   0.001449  spelunker#matches#add_matches()
    8   0.243886   0.001438  spelunker#spellbad#get_spell_bad_list()
    8   0.262130   0.001266  spelunker#words#check_display_area()
    8              0.000928  spelunker#white_list#init_white_list()
   41              0.000684  <SNR>48_Remove_Matches()

